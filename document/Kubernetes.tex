\documentclass[11pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[ngerman]{babel}
\usepackage{babelbib}
\usepackage{hologo}
\usepackage{csquotes}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}

\begin{document}

\section{Deckblatt}
\section{Inhaltsverzeichnis}



\section{Zusammenfassung}

\section{Einleitung}

Zunächst soll die Historie betrachtet werden, vor deren Hintergrund Kubernetes entstanden ist.
Das stetige Ziel, das in sich durch diese Historie zieht, ist das Bereitstellen von Applikationen.
Kominos et al. beschreiben die 1960er Jahre als Ursprung des Cloud Computing \cite{7899247}.
Zu dieser Zeit liefen Applikationen oft auf einer gemeinsamen Hardware und die Ressourcenverteilung erfolgte unmittelbar durch das zugrundeliegende Betriebssystem.
Ein derartiges Szenario (auch als "Bare-metal" bezeichnet) bringt in der Regel mehrere Herausforderungen mit sich.
Zum einen kann es schnell zu Abhängigkeitskonflikten zwischen den verschiedenen Applikationen geben.
Ist eine Applikation darauf angewiesen eine bestimmte Abhängigkeit in der Version <1.4 zu nutzen und eine andere
benötigt eine Version \(\geq 1.4\) derselben Abhängigkeit, lässt sich das nur schwer vereinbaren.
Zum anderen erschwert dieser Aufbau eine effiziente Ressourcenverteilung. Selbst wenn eine Applikation alleine auf einem Rechner betrieben wird (z.B. um Konflikte zu anderen
Applikationen zu vermeiden), muss dieser Rechner ausreichende Kapazitäten haben, um die höchsten Anfragespitzen an diese Applikation zu verarbeiten.
Selbst dann wenn diese Anfragespitzen nur äußerst selten erreicht werden.

Eine Weiterentwicklung dieser Bare-metal-Architektur waren virtuelle Maschinen. Virtuelle Maschinen erlauben es, auf derselben Hardware mehrere virtuelle Instanzen eines
Systems zu nutzen. Die Instanzen nutzen dabei nicht direkt die physischen Ressourcen, sondern lediglich virtuelle, die durch Software nachgebildet werden \cite{kofler2021docker}.
Dadurch, dass verschiedene Applikationen in verschiedenen virtuellen Maschinen betrieben werden, können Abhängigkeitskonflikte zwischen Applikationen
vermieden werden. Weiterhin sind virtuelle Maschinen leichter auszubringen und zu administrieren als Bare-metal-Lösungen.
Grundsätzlich können mit diesem Ansatz Applikationen auch flexibler und skalierbarer bereitgestellt werden.
Leistungsfähige Hardware kann Anfragespitzen einer Applikation in einer virtuellen Maschine abfangen und zu anderen Zeiten anderen virtuellen Maschinen mit anderen
Applikationen diese Ressourcen zuweisen.
Obwohl das schon einige Verbesserungen im Vergleich zu Bare-metal-Lösungen sind, haben auch virtuelle Maschinen ihre eigenen Limitationen.
Da virtuelle Maschinen jeweils Ressourcen für ein eigenes Betriebssystem beanspruchen, geht vergleichsweise viel Leistung verloren, 
die besser in der Applikation genutzt werden könnte.

Die nächste Stufe der Weiterentwicklung waren (Software-)Container. Container haben einige Gemeinsamkeiten mit virtuellen Maschinen doch der wesentliche Unterschied ist,
dass Container deutlich leichtgewichtiger sind. Das wird unter anderem dadurch erreicht, dass sie statt ein komplett eigenes Betriebssystem zu verwenden, 
Anteile des Host-Betriebssystems mitnutzen. Dadurch sind die "Baupläne" (sog. Images) für Container im Allgemeinen kleiner als für klassische virtuelle Maschinen.
Durch den verringerten Overhead können auf gleicher Hardware auch mehr Container parallel betrieben werden, als es mit virtuellen Maschinen möglich wäre.
Durch diesen Umstand und dadurch, dass Container meist innerhalb weniger Sekunden gestartet werden können, sind diese besonders geeignet,
um flexibel auf unterschiedliche Anfrageintensitäten zu reagieren und Ressourcen effizient zu verteilen \cite{kofler2021docker}.

Einzelne Container führen in der Regel nur eine klar umgrenzte Aufgabe aus (z.B. Betrieb einer Datenbank oder eines Webservers). Da sie in sich geschlossen sind,
können sie auch unabhängig von anderen Containern repliziert werden. Um eine vollständige Anwendung zu erhalten, betreibt man daher oft mehrere Container,
die im Verbund zusammenwirken; eine sogenannte Microservice-Architektur. Um den hohen Anforderungen an Rechenleistung moderner Anwendungen gerecht zu werden,
werden die Container dabei oft auf viele Rechner verteilt.
Die Verwaltung einer solchen verteilten Microservice-Architektur kann schnell komplex werden, weshalb verschiedene Werkzeuge zur Unterstützung entwickelt wurden.

Eines der heute populärsten Werkzeuge dieser Art ist Kubernetes. Im Folgenden soll die Funktionsweise von Kubernetes beschrieben und schließlich anhand eines Beispiels 
verdeutlicht werden.


% Verteilbar auf viele Maschinen?

\begin{enumerate}
	\item Bereitstellen von WebServices
	\item Direkt auf Hardware
	\begin{enumerate}
		\item Probleme (Skalierbarkeit, Verfügbarkeit, etc.)
	\end{enumerate}
	\item Virtuelle Maschinen
\end{enumerate}

\section{Hauptteil}
\begin{enumerate}
	\item Nachteile verteilter Services (s. 86ff. in Schmeling\_Dargatz\_2022)
\end{enumerate}

\section{Fazit}

\section{Ausblick}

\section{Anhang}


\section{Formatbeispiele}
\subsection{Eine Aufzählung}

\begin{enumerate}
	\item die \textbf{original PDF Vorlage} (also diese Datei),
	\item das von Ihnen erstellte \textbf{\hologo{LaTeX} Dokument} (also die .tex Datei),
	\item die von Ihnen erstellte \textbf{Literatur Datenbank} (also die .bib Datei), und
	\item das von Ihnen \textbf{kompilierte Dokument} (also die erzeugte .pdf Datei).
\end{enumerate}


\subsection{Tabellen}
Tabelle \ref{HdRTab} gibt eine kleine Übersicht über verschiedene Charaktere und Gruppierungen in \emph{Der Herr der Ringe}.

\begin{table}[b]
	\begin{tabular}{|r|c|c|c|c|}
		\hline
				& Gollum	& Legolas	& Sauron	& Gandalf \\
		\hline
		\hline
		Hobbit	& ja	& nein	& nein	& nein \\
		\hline
		Ringträger	& am Finger	& nein	& am Finger	& in der Hand \\
		\hline
		Gemeinschaft des Ringes	& nein	& ja	& nein	& ja \\
		\hline
	\end{tabular}
	\caption{Verschiedene Charaktere und Gruppierungen in \emph{Der Herr der Ringe}.}
	\label{HdRTab}
\end{table}

\subsection{Formeln}
Die bekannten Fibonacci-Zahlen $F_n$ sind wie folgt definiert.
\newtheorem{defn}{Definition}
\begin{defn}\label{fibonacci}
	Es sei $F_1 = F_2 = 1$ und $F_n = F_{n-1} + F_{n-2}$ für $n \geq 3$.
\end{defn}
Fibonacci-Zahlen treten sowohl in der Natur als auch in vielen theoretischen Anwendungen auf. Die folgende Formel für die in Definition \ref{fibonacci} wurde von verschiedenen Mathematikern im 18. und 19. Jahrhundert entdeckt. Es sei $\phi = \frac{1 + \sqrt{5}}{2}$ (der goldene Schnitt) und $\psi = \frac{1 - \sqrt{5}}{2}$. Dann gilt
\[ \forall n \in \mathbb{N}: \quad F_n = \frac{\phi^n - \psi^n}{\sqrt{5}}. \]

\subsection{Zitieren}
In Ihrer Abschlussarbeit werden Sie existierende Literatur bearbeiten und zitieren müssen. Das korrekte Formatieren übernimmt \hologo{LaTeX} (beziehungsweise \hologo{BibTeX}) für Sie. Dabei werden Sie vermutlich nicht aus dem Buch von Tolki-\linebreak en \cite{HdR1954} zitieren, aber möglicherweise aus einem Buch zum Übersetzerbau \cite{compilers2006}.

\bibliographystyle{babplain-fl}
\bibliography{literature}

\end{document}